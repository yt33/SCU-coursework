/*
 * Name: Yutong Li, W1182922
 * Title: Programming Assignment2: server.c
 * Description: This file demonstrates a UDP server that will verify the validity
 * 				of the request and respond accordingly.
 *
 * 				Server opens and reads a file named "Verification_Database.txt",
 * 				the contents of the file will be saved on the server, which contains
 * 				the subscriber's no, technology and payment status.
 *
 * 				After verifying the content of Identification request packet with the
 * 				content of the "Verification_Database.txt" file, one of the following
 * 				messages will be generated by the server:
 * 					1) subscriber has not paid
 * 					2) subscriber doesn't exist on database
 * 					3) subscriber permitted to access the network
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <socket.h>
#include <packet.h>
#include <const.h>

int main_loop(int sockfd, char **error);
int lookup_subscriber_in_database(char technology, long subscriber_no);

// 3 main cased for the server:
// 		1) initiate the connection
// 		2) receive request from the client
// 		3) exit the connection
int main(void) {
    int sockfd;
    char *error;

    // initiate the client server connection with socket creation
    if(make_socket(NULL, PORT, TRUE, &sockfd, NULL, &error) != 0) {
        fprintf(stderr, "make_socket: %s\n", error);
        return 1;
    }

    // go into a forever loop for server to receive request packet from the client
    printf("udp server started, waiting for message...\n");
    if(main_loop(sockfd, &error) != 0) {
        fprintf(stderr, "main_loop: %s\n", error);
        return 1;
    }

    // server exit the connection
    printf("udp server done.\n");
    close(sockfd);
    return 0;
}

// receive request from the client and react correspondingly
// the request will have 1 of the 3 kinds of response:
// 		1) Not exist
// 		2) Not paid
// 		3) Access OK
int main_loop(int sockfd, char **error) {
    char *message, client_id, segment_no, technology, *response;
    struct sockaddr address;
    long subscriber_no;
    int query_result;

    while(1){
        // receive packet from the client
        if(udp_recv(sockfd, &message, &address, error) != 0)
            return 1;

        // parse request packet
        if(parse_request_packet(message, &client_id, &segment_no, &technology, &subscriber_no, error) != 0) {
            fprintf(stderr, "[%s] parse_request_packet: %s\n", get_ipaddr(&address), *error);
            continue;
        }

        // lookup subscriber in database
        query_result = lookup_subscriber_in_database(technology, subscriber_no);

        // generate response for different cases
        
		// Not exist: subscriber doesn't exist on database
		if(query_result == 1) {
            printf("[%s] client[%d] request[%d]: [ %02d | %ld ] Subscriber does not exist on database\n\n", get_ipaddr(&address), client_id, segment_no, technology, subscriber_no);
            response = make_packet(client_id, NOT_EXIST_TYPE_ID, segment_no, technology, subscriber_no);

		// Not paid: subscriber has not paid
        } else if(query_result == 2) {
            printf("[%s] client[%d] request[%d]: [ %02d | %ld ] Subscriber has not paid\n\n", get_ipaddr(&address), client_id, segment_no, technology, subscriber_no);
            response = make_packet(client_id, NOT_PAID_TYPE_ID, segment_no, technology, subscriber_no);

		// Access OK: subscriber permitted to access the network message
        } else {
            printf("[%s] client[%d] request[%d]: [ %02d | %ld ] Subscriber permitted to access the network\n\n", get_ipaddr(&address), client_id, segment_no, technology, subscriber_no);
            response = make_packet(client_id, ACCESS_OK_TYPE_ID, segment_no, technology, subscriber_no);
        }

        // send corresponding response back to the client
        if(udp_send(sockfd, response, &address, error) != 0)
            return 1;
    }
    return 0;
}

// look up subscriber from the client's request using 1) technology and 2) subscriber no
// return 0 if the requested subscriber has paid and is permitted to access the newtork
// return 1 if the subscriber doesn't exist on database
// return 2 if the subscriber hasn't paid
int lookup_subscriber_in_database(char technology, long subscriber_no) {
    FILE *fp;
    char target[16], *buffer = NULL;
    int read, found = 0;
    size_t len;

    sprintf(target, "%d-%d-%d\t%02d", (int)(subscriber_no / 10000000), (int)(subscriber_no / 10000 % 1000), (int)(subscriber_no % 10000), technology);

    fp = fopen("data/Verification_Database.txt", "r");
    if(fp == NULL)
        return 1; 		// error|not exist
    while((read = getline(&buffer, &len, fp)) != -1) {
        if(strncmp(target, buffer, strlen(target)) == 0) {
            found = 1;
            break;
        }
    }
    fclose(fp);

    if(!found) {
        free(buffer);
        return 1;		// not exist
    }

	char *line;	
    for(line = buffer + strlen(target); *line; line++) {
        if(*line == '1') {
            free(buffer);
            return 0;	// paid
        }
    }

    free(buffer);
    return 2; 			// not paid
}
