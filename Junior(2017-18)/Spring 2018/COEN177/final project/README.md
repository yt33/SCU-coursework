In this project, I use hashes in order to solve an I/O or file systems' related problem.

I am writing code for a new kind of computer peripheral intended for a special kind of I/O. Specifically, this device behaves like an append-only never-to-be-modified file. The software for this device needs to accept arbitrary sequences of bytes (and so it should be able to accept input strings), and then store these strings for future evaluation. The problem is that we cannot be sure if someone has tampered with the device/file in which we are placing these strings, and it is unable to remember the full sequence of string that it receives. And so, it need to use a hash function to include with every string I write a code at the end (the result of the hash) that allows the user to check that the sequence saved is the same one that is wrote originally.

To prepare for the project, these following should be implemented:
- A map data structure
- Program that does:
	- Get string from user
		- String limit is 500 bytes
	- Search DS by key (string)
		- If not found, insert key (string) and corresponding value (hash value) to a data structure
			- Hash value is generated by Message Digest Library
		- If found, print out hash value
- Data structure should hold 1,000 Key/Value pairs

The first program (p1.c) accepts sequences of strings until an end of file is detected, and output the following:
- the length of the string
- the string itself
- the result of applying the hash function on the string
- the result of applying the hash function to the string and the preceding hash value (i.e., concatenating the string with the hash value, where the very first string assumes the preceding hash was simply the null string).

The output of this program after running is saved to a file.

The second program (p2.c) takes any such file as its input, and only prints those strings in the file that do not have a valid hash code.

The third program (p3.c) takes any such file as its input, and prints out a message indicating if it has detected an omission from the file (i.e., are there any missing strings that it could detect).


Further explanation:
1. How would I use such a program to detect duplicates strings (without modifying the programs themselves, but only using operations conducted on their output)?

The last hashed chain value would be different if there are duplicate strings.

2. How would I save spave, using the key-lookup that I have previously implemented, if I was told that the strings were very long, and that many of them were identical to each other?

Compare their hashed value. The hashed value are represented in hexdecimal, which has a fix length. Therefore, the lentgh of hased value would be really short compared to the strings original length, and it will be much easie to compare a shorter hexdecimal string.